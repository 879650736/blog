---
title: 2024秋冬季训练营第三阶段总结-张宇驰
date: 2024-12-01 10:17:57
tags:
---

# 组件化内核的意义与概念

**基于组件**构造内核的方法，去构造**不同场景**的**各种模式**内核。组件之间单向依赖。

与传统设计思路的差异：

1. 面向场景和应用需求构建内核
2. 以统一视角看待各种模式、不同规模的内核

组件化内核相对传统构建方式的优势：

1. 提高内核开发效率
2. 降低内核维护难度
3. 开展基于组件的功能复用和开发协作

内核模式：1)App和Kernel均处于S Mode.2)相互可见.3)编译形成一个Image.4)是App也是Kernel
可以通过组件增量的方式，实现扩展到宏内核与Hypervisor模式。

# Unikernel

## 学习心得

Unikernel令我最惊讶的就是模块化的OS构建方式并通过组件增量的方式组成不同内核模式的OS.

## 特点

1. 应用与内核处于同一特权级（均为内核态），共享地址空间。Unikernel既是内核又是应用，二者合为一体
2. 优点: 应用与内核之间没有隔离和切换，简单高效
3. 缺点: 同样因为没有隔离和切换，所以安全性较低

Unikernel框架与构成框架的核心组件是怎么来的？经历的阶段如下：

(1) 直接开发一个裸机应用来满足输出Hello的简单需求
(2) 需求增加，发现可按照通用性和Arch相关实现分层复用
(3) 引入组件化，降低耦合性、提升复用性定制性灵活性。

## 应用的开发

面向应用：基于features选择必要组件的最小集合。

1. 学习了如何加载和执行外部应用程序
2. 实现了内核与应用程序的通信机制
3. 掌握了地址空间分离和切换的技术要点

## 课后练习

### 练习一

在打印宏的定义处，使用ANSI控制颜色即可，我使用的是：`\x1B[34m`和`\x1B[0m`

### 练习二

我做了两版，一版就是直接引入hashbrown，这是最简单的方法，不过对于alloc和hashbrown中的有一个方法存在的冲突，我没有做处理，默认是让alloc的方法覆盖了hashbrown的。另一个版本是CV了std的实现，然后一点一点的修理，但是我还是觉得第一个更优雅一点。

### 练习三

我在EarlyAllocator中添加了start, end, b_pos, p_pos, count属性。然后将每一个Trait需要实现的函数实现出来。我发现PageAllocator中的部分函数并没有被使用，有些函数是直接打了unimplement()!的，但是一样能通过测试。

### 练习四

参数的检查可以直接参考官方函数的实现。
rename直接调用API fs::rename就可以。mv通过判断第二个参数dst是否是一个目录，如果是的话，吧文件src读入buf,然后在对应的路径写，最后删除原来的文件。

# Monolithic

## 学习心得

宏内核在如今的市场上还是占有大量的比率，而Linux也为我们证明了，宏内核加上一些合理的缓解措施，并不意味着会比其他模式差。所以，学习宏内核是很多有意义的。

## 特点

基于组件化方法构建宏内核模式。

1. Unikernel到宏内核：
  以构建最小化的宏内核为目标，说明：
  宏内核特点、与Unikernel的差异分析、框架和组件构成、具体实现示例。
2. 地址空间管理和支持Linux应用：
  1）用户地址空间映射、缺页加载机制；
  2）支持运行最简单的Linux的原始应用

Unikernel模式的应用和内核：
(1）处于同一特权级 - 内核特权级
(2) 共享同一地址空间 - 相互可见
(3) 编译形成一个Image，一体运行
(4) Unikernel既是应用又是内核，二者合体

## 课后练习

### 练习五

使用register_trap_handler来标记对PAGE_FAULT的处理，然后实现处理函数：`handle_page_fualt()`
处理的实现是通过axtask的接口去实现的，得到task的ext，将aspace上锁后，调用handle_page_fualt同名函数，最后直接打印了对应的输出，然后返回一个正确处理。如果同名函数没有正确执行，那么就直接返回false.

### 练习六

从当前的aspace中调用find_free_area，得到length的addr_src，然后进行4K对齐，同时，对length进行对齐得到size。

prot和flags通过调用MmapProt::from_bits_truncate(prot), MmapFlags::from_bits_truncate(flags)得到，需要的mappingFlags就from(prot)即可。

调用aspace的map_alloc方法。

之后处理一下MmapFlags::MAP_ANONYMOUS。如果有这个flags，直接返回就好

如果没有MmapFlags::MAP_ANONYMOUS。则通过get_file_like得到我们所需的文件，并将其读取进入buf，然后写入aspace。

# Hypervisor

## 学习心得

HyperVisor，即所谓的虚拟机管理程序，从代码实现来看，和宏内核思想差不多，都是一个高特权级的“内核”为低特权级的“应用”创建独属于它的“虚拟空间”，为它准备对应的资源，然后切换特权级去执行该“应用”。当“应用”发生“中断”的时候，就trap回“内核”处理。GuestOS，就像是一个特殊的应用。

## 特点

HyperVisor，即所谓的虚拟机管理程序，从代码实现来看，和宏内核思想差不多，都是一个高特权级的“内核”为低特权级的“应用”创建独属于它的“虚拟空间”，为它准备对应的资源，然后切换特权级去执行该“应用”。当“应用”发生“中断”的时候，就trap回“内核”处理。GuestOS，就像是一个特殊的应用。

基于一台物理计算机建立一些OS的就是虚拟机，我们这里用的是I形虚拟机，也就是不存在宿主机，直接在硬件平台运行的。
虚拟机的特点包括：同质、高校、资源受控。为了实现虚拟化，支持了以下层次的对象VM、vCPU、vMem、vDevice、vUtilities。

## 课后题

### 练习七

这里处理Trap的时候，需要更改掉panic，然后在这道题中，要求A0、A1为0x1234和0x6688，只需要在处理这些Trap的时候，将对应的寄存器进行修改就可以

---

笔记：<https://github.com/inchinaxiaofeng/Blog-arceos>
