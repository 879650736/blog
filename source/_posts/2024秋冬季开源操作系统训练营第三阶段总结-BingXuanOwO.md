---
title: 2024秋冬季开源操作系统训练营第三阶段总结-BingXuanOwO
date: 2024-12-17 19:40:21
tags:
    - author:BingXuanOwO
    - repo:https://github.com/BingXuanOwO
---

好的，这里是冰轩。

## 奇怪的 Hashmap implementation

在 Hashmap exercise 中，由于我一开始并未有实现此类数据类型的经验，参考 rust std 原有的库又有较大的心智负担，我最终选择参考《算法导论》一书中的对应部分来实现。

在 Hash 生成部分，由于我未能成功调用 rust 原有的 Hash 算法，并且我希望 Hash 算法能够相较简单，我选择了实现书中的乘法散列法算法。而至于 Hashmap 本身的实现就较为简单，其内部含有一个元素量为 Hash 最大值 + 1 的 `List<Vec>`，每个 Vec 存储一个包含了 Key 和元素的元组，每次添加时在 `List[hash_of_key]` 处推入元组，查找时从 `List[hash_of_key]` 处查找是否含有对应 key 完全相同的项。

虽然一开始因为 List 给的过大导致栈爆了，不过幸好，缩小以后，测例便成功过了。

## 带有遗憾的简易 Hypervisor

在根据根据课程逐渐熟悉框架代码以及根据课程真正了解一个 Hypervisor 的原理之后，剩下的就好说了。对两次指令的异常进行处理，然后返回正常的值，lab 就完成了...对吧？

然而我预计错了这个 lab 需要的实现方案。

这部分的实现首先需要处理一个读取 `mhartid` 的 `csrr` 指令。我一开始曾希望直接解析指令后执行对应操作，来实现 expected behavior，并确保这部分代码的鲁棒性。然而，我却想得复杂了，因为直到我开始考虑 `mhartid` 寄存器值的来源，以及发现其期望值为 0x6688，像是随便返回了一个数字，所以，我意识到，这题的实现很可能并不该如此复杂。最终，这部分我选择保留一部分之前解析并判断 Instruction 的代码，以及通过将 sepc 增加 4，并直接设置 A1 至 0x6688 的方式，直接针对结果实现。后续的 LoadGuestPageFault 我也如此实现。测试用例很轻松地过了，不出意外这个 lab 应该没太大问题了。

然而，意外还是出现了。第二天一早，我惊讶地发现它会在执行 Guest 指令时卡死。通过 LOG=trace，我发现它是在进行磁盘 io 的时候卡死。这牵扯到的问题实在太大，要进行大量的调试，更糟糕的是，这个问题触发很随机。然而，我没能在挂着调试器的情况下再见到过一次这个问题。最后，我还是放弃了解决这个问题。

## 简单快速的 h_2_0

这个 exercise 原有的 HV 框架已经给出了函数 `load_vm_image`，可以用于从磁盘读取文件并放置至地址空间，并且基本可以用于读取任何二进制文件，使得此 exercise 变得较为简单。

这个函数使得实现十分直接，我写出了一个简单的 `write_pflash_img.sh` ，用于生成带有 `pfld` Magic Number 的文件并放进磁盘镜像中。随后，注释掉原有直通模式代码，并取消注释模拟模式代码。最后，在每次缺页时，利用 `load_vm_image` 函数加载文件，并放到对应缺页的位置，这部分也就基本解决了。

与之前的简易 Hypervisor 不同，得益于对框架功能的有效复用，以及较为直接的实现，这次的实现并没有遇到随机卡死或调试困难的故障，测试用例也可以顺利通过。
